<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.15b.dev: http://docutils.sourceforge.net/" />
<title>index.rst</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id$
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

.subscript {
  vertical-align: sub;
  font-size: smaller }

.superscript {
  vertical-align: super;
  font-size: smaller }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left, table.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right, table.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

table.align-center {
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

.align-top    {
  vertical-align: top }

.align-middle {
  vertical-align: middle }

.align-bottom {
  vertical-align: bottom }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document">


<div class="section" id="gitdrive">
<h1>GitDrive</h1>
<p>This is a high level documentation for GitDrive. This will detail the
intended use of the different parts in the project, along with any limitations,
issues, and missing parts/features.</p>
<p>Each section should be stand alone as much as possible. Meaning that no knowledge
of other sections is required to understand the functionality of a section.
That being said knowledge of the program's structure is helpful in understanding
the purpose behind the decisions that were made in designing the app.</p>
</div>
<div class="section" id="the-tech-stack">
<h1>The Tech Stack</h1>
<p>Knowing the tech stack is helpful for understanding the structure. GitDrive is an Electron
app written in TypeScript. The Electron part means the app has two parts. The <em>main process</em>
and the <em>renderer process</em>.</p>
<dl class="docutils">
<dt>The main process:</dt>
<dd>Its what the app launches first, it's where the node run environment is and
it's responsible for launching the renderer process/s. This is usually seen as the backend
part where the logic is kept.</dd>
<dt>The renderer process:</dt>
<dd>Contains Chromium along with access to the node environment APIs. This is what
user interacts with and could consist of more than one window. Each window is a browser
window that renders html, css, and javascript.</dd>
</dl>
<p>These two parts communicate on channels using something called ipcMain and ipcRenderer.
The ipc part stands for intra process communication. Each process is able to set listeners and send
messages on channels on its respective ipc object.</p>
<p>This should be enough for an overall idea, for a more in depth look, the <a class="reference external" href="https://electronjs.org/docs">Electron</a> documentation
does a fantastic job. Also make sure to check <a class="reference external" href="https://github.com/sindresorhus/awesome-electron">awesome-electron</a> for everything Electron related.</p>
<p>TypeScript is a structurally typed super set of javascript. This means that the app is transpiled
into javascript. It also means the code is type checked. This makes our code easier to refractor and
write with an IDE that supports TypeScript. It is recommended to look at the TypeScript <a class="reference external" href="https://www.typescriptlang.org/docs/handbook/basic-types.html">handbook</a>
before diving into reading/writing any code.</p>
<dl class="docutils">
<dt>The rest of the stack without build related dependencies is as follows:</dt>
<dd><ul class="first last simple">
<li><a class="reference external" href="https://github.com/desktop/dugite">Dugite</a>: A Typescript binder to Git's command line.</li>
<li><a class="reference external" href="https://mochajs.org/">Mocha</a>: A test suite for javascript node applications.</li>
<li><a class="reference external" href="http://www.chaijs.com/">Chai</a>: Chai is a BDD / TDD assertion library to be used in mocha tests.</li>
<li><a class="reference external" href="https://developers.google.com/protocol-buffers/">Google-protobuf</a>: A language-neutral, platform-neutral mechanism for serializing structured data.</li>
<li><a class="reference external" href="https://vuejs.org">Vue</a>: A <em>progressive framework</em> for building responsive user interfaces. A bunch of vue related libraries are used as well.</li>
<li><a class="reference external" href="https://github.com/jprichardson/node-fs-extra">Fs-extra</a>: Adds to the native node fs module methods and adds promise support to existing ones.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="the-structure">
<h1>The structure</h1>
<p>The application is a Model-View-Controller (MVC). The Model consists of the main Git commands that are
wrapped into the app commands. The app commands are listed in <a class="reference internal" href="#the-app">The App</a>. <a class="reference internal" href="#the-controller">The controller</a> part
consists of some state-hub logic integrated into the Vuex store then components. Then <a class="reference internal" href="#the-view">the view</a>
is specified per Vue component. This makes parts of the view (components) reuseable in whichever
context the user desires.</p>
<p>The file tree structure is explained below:</p>
<ul class="simple">
<li><strong>docs</strong>: Is where this file resides, ie. the documentation.</li>
<li><strong>build</strong>: It is where the app gets transpiled.</li>
<li><dl class="first docutils">
<dt><strong>src</strong>: Where the app resides.</dt>
<dd><ul class="first last">
<li><strong>components</strong>: Where we keep the Vue components.</li>
<li><strong>examples</strong>: A bunch of examples for how the code should be used.</li>
<li><dl class="first docutils">
<dt><strong>git-drive</strong>: The logic for the app models is kept here.</dt>
<dd><ul class="first last">
<li><strong>app</strong>: The logic behind the main app commands: add-topicspace, ..., load-repo, start, ...</li>
<li><strong>controller</strong>: Where the logic for the controller is kept.</li>
<li><strong>git</strong>: The logic behind the core git commands is kept here.</li>
</ul>
</dd>
</dl>
</li>
<li><strong>main</strong>: The entry point for the main process, this is where webpack will look.</li>
<li><dl class="first docutils">
<dt><strong>model</strong>: The model class objects abstraction is kept here.</dt>
<dd><ul class="first last">
<li><strong>app</strong>: The app classes/models.</li>
<li><strong>controller</strong>: The controller classes/models.</li>
<li><strong>git</strong>: The git classes/models.</li>
</ul>
</dd>
</dl>
</li>
<li><strong>renderer</strong>: The entry point for the renderer process/s, webpack will look here.</li>
<li><strong>store</strong>: The Vuex store lies here, all the mutations, actions, and getters logic is here.</li>
<li><dl class="first docutils">
<dt><strong>tests</strong>: The app tests, they are not transpiled like the rest of the dirs in src.</dt>
<dd><ul class="first last">
<li><strong>app</strong>: Tests for the app logic.</li>
<li><strong>controller</strong>: Tests for the controller logic.</li>
<li><strong>git</strong>: Tests for the core git commands.</li>
<li><strong>testRepos</strong>: Toy repos for testing stuff on.</li>
</ul>
</dd>
</dl>
</li>
<li><strong>util</strong>: Utility functions that might be useful for any other parts in the app.</li>
</ul>
</dd>
</dl>
</li>
<li><strong>static</strong>: Files that are used as is.</li>
<li><strong>.electron-vue</strong>: The webpack config and run scripts are here.</li>
<li><strong>template</strong>: Like static but its meant to be used by users not the app itself.</li>
</ul>
<hr class="docutils" />
<p>Notice how the <em>git-drive</em>, <em>model</em> and <em>tests</em> directories share the same structure.</p>
<p>The <a class="reference internal" href="#protobuf">protobuf</a> coupling/abstraction is specified within each model.</p>
</div>
<div class="section" id="the-build-process">
<h1>The Build Process</h1>
<p>Our build process is not that involved but not trivial at the same time. Looking at the <a class="reference external" href="../package.json">package.json</a>
scripts we notice 11 of them, most are not stand alone callable, here is the layout:</p>
<div class="section" id="dev-build">
<h2>Dev-Build</h2>
<p>The start script is the one responsible this and has four steps. The first one is just cleaning the
build directory. The second step transpiles the app from TypeScript to javascript into the build
directory. The third runs the linter, based on the rules in <a class="reference external" href="../tsconfig.json">tsconfig.json</a>. The fourth and last,
actually launches the app using webpack from the build/main and build/renderer directories</p>
</div>
<div class="section" id="production-build">
<h2>Production-Build</h2>
<p>The dist (short for distribute) scripts are responsible for this. So far this is not functional.
I will finalize this and update the section accordingly.</p>
</div>
<div class="section" id="app-packaging">
<h2>App-Packaging</h2>
<p>The pack scripts are responsible for this. So far this is not functional as well. Will update
the section once it is functional.</p>
</div>
<div class="section" id="testing">
<h2>Testing</h2>
<p>The test script is the one responsible for this. The script runs any tests specified in the
src/test directory. The test assume the ts-node npm module to be installed globally as it is
responsible for transpiling the TypeScript tests in runtime thus it is not possible to run the
tests without it.</p>
<hr class="docutils" />
<p>Notice how I did not go through any of the webpack setup or build configs. They are very standard
and self explaining to whoever knows anything about webpack. I know enough to make what is there now
work.</p>
<p>One thing worth mentioning is that none of the components are actually transpiled, they are compiled
in runtime using vue-loader and a bunch of other modules. This means when any of these are referenced,
ie. imported, they are referenced with respect to them existing in src/components directory not build/*
directory like the rest of the code.</p>
</div>
</div>
<div class="section" id="terminology">
<h1>Terminology</h1>
<p>Below are formal definitions of each concept. Use this to help reason about and understand them.</p>
<div class="section" id="grepository">
<h2><strong>GRepository</strong></h2>
<blockquote>
Our own definition of a repository. It will consist of a group of one or more TopicSpaces.
Each repository has a &quot;Main&quot; topicspace among maybe other ones. The repository has a name that
cannot be longer than a 100 character. Also each user in the repository must have a unique
name. Along with all the workspace branches, each repository has a metadata branch called &quot;GH&quot;.
For more information on how metadata is kept, read sectoin <a class="reference internal" href="#how-to-do-we-keep-metadata">How to do we keep metadata</a>
Finally, each repository can have none or only one remote repository linked to it. If it exists,
the name of the remote repository is &quot;origin&quot;.</blockquote>
</div>
<div class="section" id="topicspace">
<h2><strong>TopicSpace</strong></h2>
<blockquote>
A group of at least one or more WorkSpaces. Since each workspace can only have one user,
the number of users has to match the number of workspaces. The name as well has to be less
than a 100 characters. An in depth explanation of the structure of any topicspace can be found
in the <a class="reference internal" href="#protobuf">protobuf</a> section.</blockquote>
</div>
<div class="section" id="workspace">
<h2><strong>WorkSpace</strong></h2>
<blockquote>
A single branch for one user only. Meaning that only the user is allowed to commit on this branch.
This way we can get who the user is by reading the tip's commit author information. The name of
the branch starts with a capital &quot;G&quot; letter then the first 10 characters in the first
commit's SHA. The &quot;G&quot; is added to avoid ambiguity in Git when referencing the branch ref and
actual commit SHAs. This naming schema grants us unique names for quite a long time, a full proof
way is to make the length of the SHA characters adapt to the total number of workspaces, maybe one
day in the future. Choosing the first commit's SHA was deliberate as it offers us a quick way of
reading the first commit's information and of referencing it along with the branch's tip when
doing a ranged log to retrieve all the commits on the workspace for example.</blockquote>
</div>
<div class="section" id="sync">
<h2><strong>Sync</strong></h2>
<blockquote>
For a user and a workspace, the operation does a commit followed by a push of the workspace then
a fetch of all workspaces. This requires the branch checked-out to match the given workspace. It
will also check that the given user owns the given workspace.</blockquote>
</div>
<div class="section" id="dispatcher">
<h2><strong>Dispatcher</strong></h2>
<blockquote>
Where all the data-flow is handled along with events. It can control one or more app states. Any
reads, writes to data should go through here. This will ensure the consistency of such operations
and will make extending on them easier.</blockquote>
</div>
<div class="section" id="app-state">
<h2><strong>App-State</strong></h2>
<blockquote>
A state that is tied to a browser window and app-data. The browser window coupling is not done
yet. As for the app-data, this class is responsible for mutating the app-data state in a
consistent way. This means creating a new object with every mutation since app-data is immutable.
This class is also responsible for exposing any information from app-data. One might ask by now
why not have app-data as a part of the Dispatcher instead of doing this. The reason is for the
future where the app might have multiple windows in which dispatcher (or an api it will call) will
be tasked with keeping information between them consistent.</blockquote>
</div>
<div class="section" id="fs-explorer">
<h2><strong>FS Explorer</strong></h2>
<blockquote>
The right bottom panel responsible for exploring the currently selected workspace. It will show
directories/files and offer operations on them accordingly. These operations are tbd but one
will be to show the history progression. This means show the linear line of commits that affected
the directory or file in the selected workspace.</blockquote>
</div>
<div class="section" id="header-menu">
<h2><strong>Header Menu</strong></h2>
<blockquote>
Its the top panel where the app commands will reside. These commands will chang based on their
context, ie. the current repository, current topicspace, and current workspace.</blockquote>
</div>
<div class="section" id="ts-pane">
<h2><strong>TS Pane</strong></h2>
<blockquote>
Its the left panel where the user browses the current repository's topicspaces and workspaces.
WorkSpaces are named based on their users.</blockquote>
</div>
<div class="section" id="app-data">
<h2><strong>App Data</strong></h2>
<blockquote>
The metadata that will be cached in between app sessions, such as current repository,
current user, repositories, etc. This class is coupled with a protobuf message, thus this is
how it will be written and read.</blockquote>
</div>
<div class="section" id="store">
<h2><strong>Store</strong></h2>
<blockquote>
The Vuex store, where the controller (dispatcher) meets the view. So the Vue component tree
only allows for information to flow from parents to children using something they call props.
This proves difficult if sibling components want to communicate information with each other.
This problem can be solved by using a global data store as a single source of truth in which
the entire component tree has access to the data in it using a defined set of interactions.
These interactions are either getting the data, mutating the data, or doing an async action
that might mutate the data eventually. By doing this our state transitions are clear to
follow and thus debug.</blockquote>
</div>
</div>
<div class="section" id="common-errors">
<h1>Common Errors</h1>
</div>
<div class="section" id="the-git-core">
<h1>The Git Core</h1>
<p>This section assumes a certain level of comfort with Git commands, terminology and concepts.</p>
<p>The section will consist of the core Git commands that we wrap around with the help of dugite.
A lof of these are inspired or sometimes copied from the <a class="reference external" href="https://github.com/desktop/desktop">GitHub Desktop</a> project, thanks
to them for that.</p>
<p>The list below will have commands that are exposed in multiple ways that depend on the
options given to the command. So in reality we have 37 Git commands/functions
exposed. If necessary, each command will also have an explanation of the purpose from including
it along with an explanation of why its exposed in such a way.</p>
<p>Also all the commands will not attempt to handle any error they encounter and will throw it
to the caller. The errors thrown follow the structure explained under core-git below.</p>
<p>Here are the commands in alphabetical order:</p>
<blockquote>
<dl class="docutils">
<dt><strong>1.Add:</strong></dt>
<dd><p class="first">There is one function from the add command.</p>
<p class="last">1) <em>addAllToIndex(repo: Repository, addOptions?: IAddToIndexOtions)</em>:
It stages everything in the working tree. All changes no matter what they
will get staged. We do not expose partial staging (staging per file) since we have no
use for it in our functionality. Partial staging is still achievable, if needed,
using partial resets. A partial reset with the right option will effectively undo
an add. The addOptions param is experimental, ie. not tested at all.</p>
</dd>
<dt><strong>2.Branch:</strong></dt>
<dd><p class="first">We have two functions from the branch command.</p>
<p>1) <em>createBranch(repo: Repository, name: string, tip: string)</em>: Creates a branch, which
given a valid name with length less than a 101 characters and a committish tip will
create a branch at the committish. HEAD has to be explicitly specified to avoid ambiguity.</p>
<p class="last">2) <em>renameBranch(repo: Repository, branch: Branch, newName: string)</em>: The second is
renaming a branch, which given a branch and a new valid name
will rename the branch to that name. We use rename while creating workspaces to rename
temp branches after we create the first commit on them since we need the first 10
SHAs characters from it.</p>
</dd>
<dt><strong>3.Checkout:</strong></dt>
<dd><p class="first">We have four functions from the checkout command.</p>
<p>1) <em>checkoutBranch(repo: Repository, branch: Branch | string)</em>: Just a
normal checkout of a ref. Usually the ref will be a branch object,
in fact this command is only used to checkout branches. The reason behind accepting
a string is because of metadata branches. It turned out its a lot of headache to keep
track of the metadata branch in a branch object so we only keep track of its ref name
per repository and we used that name (string) to check it out when needed.</p>
<p>2) <em>partialCheckout(repo: Repository, targetRef: string, paths: ReadonlyArray&lt;string&gt;)</em>:
Our beloved partial checkout. Given a list of paths and ref, the command
will checkout the state of those paths based on the ref into the current working tree.
This operation should be run on an empty workspace.</p>
<p>3) <em>orphanCheckout(repo: Repository, branchName: string, startPoint: string)</em>: An
orphan checkout. Given a new branch name and a starting point, it will
create an orphan branch based on the point. An orphan branch points to no commits,
effectively breaking the history. This will be used when we create a new topicspace
to ensure their independence. It is the caller's responsibility to create a commit on
an orphan branch before checking out any other branch since an orphan branch with no
commits gets discarded upon checking out anther branch.</p>
<p class="last">4) <em>checkoutAndCreateBranch(repo: Repository, branchName: string, startPoint: string)</em>:
Create and checkout a branch. Given a branch name and a start point
it creates a branch at that point and checks it out. This is just here to save us a
shell-out call, its two birds with one stone.</p>
</dd>
<dt><strong>4.Clone:</strong></dt>
<dd><p class="first">We have one function from the clone command.</p>
<p>1) <em>clone(url: string, path: string)</em>: Your normal clone call. Given a valid url and a
path, it will clone the url repository into that path.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notice:</th><td class="field-body">There is a bit of work to be done on that command. We still
need to figure out authentication. We disable the use of any default authentication
handlers in order to implement ours. Will update the section once its done.</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>5.Commit:</strong></dt>
<dd><p class="first">We have one function from the commit command.</p>
<p class="last">1) <em>commit(repo: Repository, name: string, email: string, summary: string, message:
string)</em>: A commit but with stuff baked in it. So given an author's name and email, a summary
and a message, it will create a commit under HEAD with author and email set. Before
committing, it will unstage everything then stage it all again.</p>
</dd>
<dt><strong>6.core-git:</strong></dt>
<dd>This is just a wrapper around the dugite exec command. The wrapper is meant to be used
to extend on the error handling and result of dugite's api. The class GitError defines
our errors in which each error having a human readable description of the error,
the errored command's arguments, the error enum from dugite/errors.ts, and the
actual text of the error. An error is triggered whenever the process returns with a none
zero exit code. The wrapper does not attempt to handle any errors, its all left to the
caller.</dd>
<dt><strong>7.Diff-index:</strong></dt>
<dd><p class="first">We have one function from the command. The code for this was taken from the
<a class="reference external" href="https://github.com/desktop/desktop">GitHub Desktop</a> project.</p>
<p class="last">1) <em>getIndexChanges(repository: Repository)</em>: As the name suggests, the command will
return a list of of files who have changes in the indexing when compared against HEAD.</p>
</dd>
<dt><strong>8.Diff:</strong></dt>
<dd><p class="first">We have five functions from the diff command. The code for this was take from the
<a class="reference external" href="https://github.com/desktop/desktop">GitHub Desktop</a> project.</p>
<p>1) <em>getCommitDiff(repository: Repository, file: FileChange, commitish: string)</em>:
Gets a commit's diff. Given a file and a commitish, it will return
the diff of the file between the commit and the commit's parent. This could be used to
check if a commit introduces a change to a file. This command is actually an exception in
the fact that it uses log instead of the diff command, it returns a diff though and thats
what matters.</p>
<p>2) <em>getWorkingDirectoryDiff(repository: Repository, file: WorkingDirectoryFileChange)</em>:
Gets a diff between a file and the working tree. Given a file, the
command renders the diff for a file within the repository working tree. The file
will be compared against HEAD if it's tracked, if not it'll be compared to an empty
file meaning that all content in the file will be treated as additions.</p>
<p>3) <em>getImageDiff(repository: Repository, file: FileChange, commitish: string)</em>:
Gets an image diff. This is not going to be used for now, it is there
since I didn't write this code.</p>
<p>4) <em>convertDiff(repository: Repository, file: FileChange, diff: IRawDiff, commitish:
string, lineEndingsChange?: LineEndingsChange)</em>:
This is a utility function that converts rawDiff or changes to an IDiff object. This
is implementation specific, its exported since it might be useful given the type of diff
a user posses. Explaining the command is tedious and not necessary.</p>
<p class="last">5) <em>getBlobImage(repository: Repository, path: string, commitish: string)</em>:
Gets a binary blob of an image. Again for now this is not used.</p>
</dd>
<dt><strong>9.Fetch:</strong></dt>
<dd><p class="first">There are two functions from the fetch command.</p>
<p>1) <em>fetchAll(repo: Repository)</em>:
Just a fetch of all the refs in a repository. Given that our repositories will
only have one remote branch called origin then we fetch all the refs from it. Notice how the
command does not check whether the remote repository exist in the given repository. This
check if left for the caller to do as it might become redundant.</p>
<p>2) <em>fetchRefspece(repo: Repository, refspec: string)</em>:
Fetches a specific ref. Given the name of the ref the function will fetch
it down. Again this does fetch from origin and does not check whether the remote repository
exists. This also does not check the existence of the given ref.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notice:</th><td class="field-body">The authentication is not implemented for this as well, in fact it is not
implemented for any network related command.</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>10.For-each-ref:</strong></dt>
<dd><p class="first">There is one function from this command.</p>
<p class="last">3) <em>getBranches(repository: Repository, ...prefixes: string[])</em>:
A getter for refs in the repository based on a namespace. So given a namespace, the
command will return an array with all the refs under the namespace. For example, giving
the command refs/heads will return all the local branches. Another example is giving the
command remotes/origin will return all the remote refs from remote repository origin. Call
the function with just a repository to get all the refs.</p>
</dd>
<dt><strong>11.Init:</strong></dt>
<dd><p class="first">There is one function from this command.</p>
<p class="last">1) <em>init(pathToRep: string)</em>:
Just an init of a repo given a path that exists. Notice that the function does not
check if the path exists, this is left for the caller.</p>
</dd>
<dt><strong>12.Log:</strong></dt>
<dd><p class="first">There are three functions from this command. This code was taken from the <a class="reference external" href="https://github.com/desktop/desktop">GitHub Desktop</a>
project.</p>
<p>1) <em>getCommits(repository: Repository, revisionRange: string, limit: number,
additionalArgs: ReadonlyArray&lt;string&gt; = [])</em>:
A getter for commits. Given a revision range (a git defined concept), and a
limit, the command will return an array of the commits that fall within the range.</p>
<p>2) <em>getChangedFiles(repository: Repository, sha: string)</em>:
Gets the changed files per commit. Given a commitish, the command will
return an array the files that were changed by the commit.</p>
<p class="last">3) <em>getCommit(repository: Repository, ref: string)</em>:
Retrieves a single commit based on a ref. Given a ref, the command will return
the commit the ref is pointing to or null if the ref doesn't point to a commit.</p>
</dd>
<dt><strong>13.Pull:</strong></dt>
<dd><p class="first">There is one function from the pull command.</p>
<p>1) <em>pull(repo: Repository)</em>:
Just a normal pull of the current HEAD. This should not be used and is there only for the
possibility of needing it. The main problem is that users can make commits through GitHub,
commits that won't follow our rules and we have to deal with it. We will see. We maybe able to
tolerate the owner of the branch rebasing some remote commits made on their own branch.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notice:</th><td class="field-body">Authentication is not implemented.</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>14.Push:</strong></dt>
<dd><p class="first">Similar to fetch, there are two functions from the push command.</p>
<p>1) <em>pushBranch(repo: Repository, localBranch: string)</em>:
Just a push of a branch. Given a branch name, the command will push it to its
tracked upstream branch, origin in our case.</p>
<p>2) <em>pushAll(repo: Repository)</em>:
A push of all refs. Again this will push to origin.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notice:</th><td class="field-body">None of these commands checks if origin is setup, this is left to the caller.
Also authentication is not implemented.</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>15.Remote:</strong></dt>
<dd><p class="first">There are three functions from the remote command.</p>
<p>1) <em>getRemote(repo: Repository)</em>:
A getter for a remote. Given a repository, the command will return the one and
only remote as an IRemote object, the object will contain the name and url.</p>
<p>2) <em>addRemote(repo: Repository, url: string)</em>:
Adds origin. Given a url, the command will add origin with the url into the
remote repositories configs.</p>
<p class="last">3) <em>changeUrl(repo: Repository, newUrl: string)</em>:
Changes the remote repository. Given a new url, the command will change the
url of origin to the url given.</p>
</dd>
<dt><strong>16.Reset:</strong></dt>
<dd><p class="first">There are three funcitons from the reset command.</p>
<p>1) <em>reset(repo: Repository, targetRef: string, mode: ResetMode)</em>:
A ref based reset. Given a ref and a reset mode, the command will reset the
current working tree to that ref based on the mode given.</p>
<p>2) <em>restPath(repo: Repository, targetRef: string, mode: ResetMode,
paths: ReadonlyArray&lt;string&gt;)</em>:
A path based reset. Given a ref, a mode and a list of paths, the command will
reset the current working tree's paths to the state in the ref based on the mode.</p>
<p>3) <em>slicePathsReset(repo: Repository, firstArgs: string[], paths: ReadonlyArray&lt;string&gt;)</em>:
A HEAD based reset. When called on a repo, the command will effectively
un-stage all the changes in the current working tree.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notice:</th><td class="field-body">Given the ResetMode enum, there are only two reset modes possible to use,
soft and mixed resets. Hard resets are not possible.</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>17.Rev-parse:</strong></dt>
<dd><p class="first">There are two functions from the rev-parse command.</p>
<p>1) <em>getTopLevelWorkingDirectory(path: string)</em>:
A getter for the top level path of a repository. Given a path, the function
will return the top level absolute path of that git repository or null if it isn't a
git repository.</p>
<p class="last">2) <em>isGitRepository(path: string)</em>:
Verifies whether the path is a root of a git repository. Given a path, the
function will use the one above to return whether the path is the root path in a
repository or it isn't. This is used to determine whether we can start a repository
at a path or not, because if its already a repository we cannot. The fact that we
only care about the root path is because we want the user to be able to nest their
repositories within each other. Nesting repositories is easy as long as the
.gitignore files are updated correctly.</p>
</dd>
<dt><strong>18.Show:</strong></dt>
<dd><p class="first">There are two closely related functions from the show command.</p>
<p>1) <em>getBlobBinaryContents(repo: Repository, commitish: string, filePath: string)</em>:
Gets the binary blob content of a file based on a commit. Given a commitish,
and a path, the function will return a buffer that contains the contents of the file
based on the commitish. This function is super helpful when reading from the metadata
branch for example. Using it we are able to read the metadata protobuf file without
having to checkout the branch.</p>
<p class="last">2) <em>getPartialBlobBinary(repo: Repository, commitish: string, filePath: string,
length: number)</em>:
Just like the first except that it takes a length argument. The length
represents the maximum amount of bytes to be read from the file. This is helpful if
its anticipated the file is going to be too big.</p>
</dd>
<dt><strong>19.Statues:</strong></dt>
<dd><p class="first">There is one function from the statue command. This code was taken from the
<a class="reference external" href="https://github.com/desktop/desktop">GitHub Desktop</a> project.</p>
<p>1) <em>getStatus(repository: Repository)</em>:
Getter for the current working tree status based from the top level of the
repository. When run on a repository the command will return an IStatusResult object
that contains: The name of the current branch, the current upstream branch
(if it exists), the current tip commit's SHA, whether the branch is ahead or
behind its upstream, if the repository exists, and lastly a WorkingDirectoryStatus
object that has a list of WorkingDirectroyFileChanges of the current files to be
staged in the current working tree.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notice:</th><td class="field-body"><p class="first">There is no explicit notion of partial staging, the way to do it is to give
the WorkingDirectoryStatus class (in model/status.ts) a selected list of
WorkingDirectroyFileChanges.</p>
<p class="last">Also the command will not have any relative paths for the files it returns
since it is run from the top level of the repository. The status command's
output changes based on the current <em>working directory</em>.</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</blockquote>
</div>
<div class="section" id="models">
<h1>Models</h1>
</div>
<div class="section" id="protobuf">
<h1>Protobuf</h1>
<p>So we use <a class="reference external" href="https://developers.google.com/protocol-buffers/">Google's protobuf</a> to serialize our our metadata and store it. Our protobuf files are
in the <a class="reference external" href="../static/proto-models">static/proto-models</a> directory. The directory includes proto3 definitions of each model
in the src/model directory and javascript generated code.</p>
<p>The rules for protobuf messages generated code change per language. This <a class="reference external" href="https://developers.google.com/protocol-buffers/docs/reference/javascript-generated">page</a> has all the
information needed for javascript. One thing to keep in mind is if a message field is not
available then its undefined by default. The command bellow is run from the proto-models
directory to generate the javascript code from the proto files.</p>
<pre class="literal-block">
rm *.js &amp;&amp; ../protoc/bin/protoc.exe --proto_path=./ --js_out=import_style=commonjs,binary:./ committerid.proto
commit.proto user.proto branch.proto repo.proto topicspace.proto workspace.proto grepo.proto app-data.proto
</pre>
<p>Given the generated code above, each class in the model directory uses its generated code to
create the messages under the hood. What under the hood means is each class has only one
public member which is the proto message object. Using the proto message object, each class has
a set of getters to expose its members. The proto message object is always initialized in the
constructor, and has its proto message fields set in the constructor as well. The getters use
the proto message object to retrieve the fields, convert them into objects from messages if
needed, then return them to the user.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notice:</th><td class="field-body"><p class="first">This conversion into object from proto message results in the following weirdish behavior:
The memory address of an object passed to a constructor is not the same as the one retrieved
from a getter. Its the same object in terms of content. So for example if we pass
committerID object with address x to the Commit constructor then try and retrieve it later,
we will get a new committerID object with address y. They will have the same content exactly
even though they are two different addresses underneath. They also have the same exact
protobuf object, in content and address.</p>
<p class="last">Conclusion, two object are equal iff their content is equal or their protobuf objects are
the same.</p>
</td>
</tr>
</tbody>
</table>
<p>Each proto message object has this naming scheme &quot;[className]ProtoBuf&quot;, with a lowercase class
name.</p>
<p>Along with the above, each model class has two more public methods.</p>
<p>The first is a static class method to deserialize protobuf messages. For this to work, each
constructor is overloaded to accept <em>just</em> a protobuf message. This way we can initialize a
class using just the protoBuf message by setting the protobuf message object to the given proto
message. And given the way the getters are made, all the members will be read from the message
without us needing to read them out to set them in the constructor.</p>
<p>The second method is a none static public serialize method. This will return the serialized
binary array of the proto message object for it to be sent over the wire or stored on disk.</p>
<div class="section" id="how-to-do-we-keep-metadata">
<h2>How to do we keep metadata</h2>
<p>For each GRepository, the metadata will be saved in a &quot;repo.proto&quot; file at the root of the
repository. The file will include a serialized GRepository object.</p>
<p>As discussed in the definitions, each GRepository has a metadata branch called &quot;GH&quot;. The reason
behind choosing GH is to break the <a class="reference internal" href="#workspace">workspace</a> naming convention while being as short as possible.
The main purpose of the metadata branch is to keep track of the structure changes in the repository.
This means, keep track of the additions or removals of topicspaces or workspaces. This is not
possible to do by just recording the metadata upon each commit like we already do. This is the case
because of the following example:</p>
<blockquote>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Disclaimer:</th><td class="field-body">The following example is not representative of how the protobuf data is stored, its
simplified. Read the rest of the section for the full picture.</td>
</tr>
</tbody>
</table>
<p>Let's say we have three users working on a topicspace and the commit graph looks like this:</p>
<pre class="literal-block">
     __[2]--[3]
    /
[1]-- --[4]
    \
     --[5]--[6]--[7]              Each [x] represents a commit.
</pre>
<p>For the sake of simplicity let's assume that all the users are aware of each other's existence,
meaning that reading the &quot;repo.proto&quot; file from any commit on any workspace, ie. commits
{2,3,4,5,6,7}, will result in a deserialized object that has one topicspace with three workspaces.</p>
<p>Now lets say we have a fourth user who joins the topicspace as such:</p>
<pre class="literal-block">
     __[2]--[3]
    /
[1]-- --[4]
    \
     --[5]--[6]--[7]
        \
         --[8]                     Each [x] represents a commit.
</pre>
<p>Since we save the protobuf file with each commit, only commit [8] is aware of the existence of
the new workspace. Its simple for other users to become aware of the addition, since
they will each get a new branch once they sync with the remote repository.</p>
<p>The problem resides when this repository is cloned at this state. Unless the cloning algorithm
reads every &quot;repo.proto&quot; file from each workspace in the repository it might not know about the
last workspace existence.</p>
<p>The problem is solved by having a single source of truth for reading the structure of the
repository, the metadata branch &quot;GH&quot;. As you might have guessed by now, having one branch
with multiple people committing on it means we will be dealing with merge conflicts. This is
true but sort of trivial. Comparing the different metadata files with removals taking precedent
should result in the most up to date file. The algorithm for this is yet to be implemented since
we don't have a merge command. I will update the section once its done.</p>
</blockquote>
<p>The metadata branch is only written to after running these commands: startRepo, createTopicSpace, and
createWorkSpace.</p>
<p>So I sort of lied in the last example. There is yet another problem when saving metadata upon committing.
The metadata has no way of recording metadata about the commit its read from. The example below explains
why:</p>
<blockquote>
<pre class="literal-block">
[1]--[2]
</pre>
<p>Let's assume our metadata keeps track of the commits in the history above. This information
would look something like the SHA of the commit, author, data, time, summary, and message.
Most of this information is not available before making the actual commit.</p>
<p>Meaning if the metadata file was written to disk before committing [1], it will only have
info about the author, summary and message. This metadata is incomplete. Commit [2] works
similarly except that it has full information about commit [1].</p>
</blockquote>
<p>As the example above showed, the metadata about the commit to be made is incomplete. This is why
I chose not to save the any metadata about the commit that's about to be made. This means:</p>
<blockquote>
(1) Any repo.proto file state with regards to commits on workspaces is <em>at least</em> one commit
behind when compared to where the actual ref (branch) points.</blockquote>
<p>The at least part is for the fact that other users could have made several commits on their
workspaces that the current repo.proto file has no information about. So:</p>
<blockquote>
(2) A repo.proto file read from a workspace is <em>exactly</em> one behind the ref (branch) pointer
for that workspace.</blockquote>
<p>All this is a headache to deal with when it comes to creating a topicspace. This is why:</p>
<blockquote>
<pre class="literal-block">
     __[2]
    /
[1]-- --[3]
    \
     --[4]                           Each [x] represents a commit.
</pre>
<p>Here we have commit [1] as the initial state, it can be retrieved by reading the firstCommit
property of the topicspace class. Given all the above, commit [2] metadata has knowledge of
commit [1] only. Commit [3]'s metadata has knowledge of commit [1] and [2] only. And so on.</p>
<p>Since we don't keep partial metadata, we don't write any &quot;repo.proto&quot; files in the first commits
of workspaces that were created using startRepo. The main reason is that throughout the execution
of startRepo, we don't have a GRepository object to serialize until the end of the method.
This is not the case for any workspace created using createWorkSpace. It is inconsistent but
its kept since the distinguishing information might be useful down the line.</p>
<p>There is another reason why metadata should not be read from first commits on workspaces, its
left for the reader to reason about. Hint: it has to do with adding topicspaces.</p>
</blockquote>
<p>Speaking of startRepo, we have another exception to a rule. The committer and author of a commit
should match with maybe the exception of the first commits on a workspace. This happens when a user
specifies the users for a topicspace they are about to create. Since the author of a commit can be
set manually, we do set it accordingly for each user and their workspace. But we cannot set the
committer field, thus the exception. This should have no effect on how the app operates since we
rely on the author field to verify things. This is only problematic if someone tries to maliciously
introduce commits that we believe are valid. This is fixable with enforcing GPG signing of commits.</p>
<p>The exception is fixable if we find a way of communicating an invite to a topicspace, that way only
when a user accepts the invite they will create their workspace. This will happen down the line, for
now it is not necessary.</p>
<p>Finally, we also keep track of the current user in a file called &quot;.CURRENT_USER&quot; located at the root
of the repository. The reason behind this file's existence is mainly to introduce a change in
between workspaces when they are created. If we have no changes we cannot commit. The file just
includes the user's name and nothing else.</p>
</div>
</div>
<div class="section" id="the-app">
<h1>The App</h1>
<div class="section" id="startrepo">
<h2>StartRepo</h2>
<p>Creates a repository in the given path with the given users. Meaning that each user will have a
workspace in the default &quot;Main&quot; topicspace. A path is valid if it exists and has no repository
initialized in it. The method also copies the default .gitignore file from the static directory.</p>
<p>The method returns the new repository.</p>
<p>The &quot;GH&quot; branch will be checked-out at the end of the method's execution.</p>
</div>
<div class="section" id="createtopicspace">
<h2>CreateTopicSpace</h2>
<p>Creates a topicspace with the given users based on a commit. The new topicspace will be an orphan
checkout based on the given commit's state.</p>
<p>The method returns a pair of objects, the first is the repository with the new topicspace added
to it, and the second is the topicspace created.</p>
<p>The &quot;GH&quot; branch will be checked-out at the end of the method's execution.</p>
</div>
<div class="section" id="createworkspace">
<h2>CreateWorkSpace</h2>
<p>Creates a workspace in the given topicspace based on a workspace. The new workspace being based on
the latest state of another workspace is for simplicity. In fact, I will also add the ability to
base the new workspace on the initial state of the topicspace or just an empty state.</p>
<p>The method returns a pair of objects, the first is the repository with the new workspace added to
it, and the second is the workspace created.</p>
<p>The &quot;GH&quot; branch will be checked-out at the end of the method's execution.</p>
</div>
<div class="section" id="download">
<h2>download</h2>
<p>Downloads the repo. To be implemented.</p>
</div>
<div class="section" id="loadgrepo">
<h2>loadGRepo</h2>
<p>Given a path, checks whether it adheres to our rules then reads it out, if it doesn't it will
error out. Even though its tedious to check for all the rules, this method doesn't take long
to execute.</p>
</div>
<div class="section" id="partialcheckouts">
<h2>partialCheckouts</h2>
<p>Partially checkout a file or a directory along with its sub-directories or not.</p>
</div>
<div class="section" id="id1">
<h2>Sync</h2>
<p>Writes the repository state to memory then commits in the given workspace for the given user,
with the given commit summary and message. This method does the necessary checks to ensure
only the user who owns the workspace is committing in it. This method will also push the changes
and fetch the rest of the branches if the remote repository exists. Handling the new changes
from pulled branches is yet to be implemented.</p>
</div>
</div>
<div class="section" id="the-controller">
<h1>The Controller</h1>
</div>
<div class="section" id="the-view">
<h1>The View</h1>
<img alt="./mockup.PNG" src="./mockup.PNG" />
</div>
<div class="section" id="limits">
<h1>Limits</h1>
</div>
<div class="section" id="git-errors">
<h1>Git Errors</h1>
</div>
</div>
</body>
</html>
