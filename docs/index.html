<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<meta name="generator" content="Docutils 0.15b.dev: http://docutils.sourceforge.net/" />
<title>index.rst</title>
<style type="text/css">

/*
:Author: David Goodger (goodger@python.org)
:Id: $Id$
:Copyright: This stylesheet has been placed in the public domain.

Default cascading style sheet for the HTML output of Docutils.

See http://docutils.sf.net/docs/howto/html-stylesheets.html for how to
customize this style sheet.
*/

/* used to remove borders from tables and images */
.borderless, table.borderless td, table.borderless th {
  border: 0 }

table.borderless td, table.borderless th {
  /* Override padding for "table.docutils td" with "! important".
     The right padding separates the table cells. */
  padding: 0 0.5em 0 0 ! important }

.first {
  /* Override more specific margin styles with "! important". */
  margin-top: 0 ! important }

.last, .with-subtitle {
  margin-bottom: 0 ! important }

.hidden {
  display: none }

.subscript {
  vertical-align: sub;
  font-size: smaller }

.superscript {
  vertical-align: super;
  font-size: smaller }

a.toc-backref {
  text-decoration: none ;
  color: black }

blockquote.epigraph {
  margin: 2em 5em ; }

dl.docutils dd {
  margin-bottom: 0.5em }

object[type="image/svg+xml"], object[type="application/x-shockwave-flash"] {
  overflow: hidden;
}

/* Uncomment (and remove this text!) to get bold-faced definition list terms
dl.docutils dt {
  font-weight: bold }
*/

div.abstract {
  margin: 2em 5em }

div.abstract p.topic-title {
  font-weight: bold ;
  text-align: center }

div.admonition, div.attention, div.caution, div.danger, div.error,
div.hint, div.important, div.note, div.tip, div.warning {
  margin: 2em ;
  border: medium outset ;
  padding: 1em }

div.admonition p.admonition-title, div.hint p.admonition-title,
div.important p.admonition-title, div.note p.admonition-title,
div.tip p.admonition-title {
  font-weight: bold ;
  font-family: sans-serif }

div.attention p.admonition-title, div.caution p.admonition-title,
div.danger p.admonition-title, div.error p.admonition-title,
div.warning p.admonition-title, .code .error {
  color: red ;
  font-weight: bold ;
  font-family: sans-serif }

/* Uncomment (and remove this text!) to get reduced vertical space in
   compound paragraphs.
div.compound .compound-first, div.compound .compound-middle {
  margin-bottom: 0.5em }

div.compound .compound-last, div.compound .compound-middle {
  margin-top: 0.5em }
*/

div.dedication {
  margin: 2em 5em ;
  text-align: center ;
  font-style: italic }

div.dedication p.topic-title {
  font-weight: bold ;
  font-style: normal }

div.figure {
  margin-left: 2em ;
  margin-right: 2em }

div.footer, div.header {
  clear: both;
  font-size: smaller }

div.line-block {
  display: block ;
  margin-top: 1em ;
  margin-bottom: 1em }

div.line-block div.line-block {
  margin-top: 0 ;
  margin-bottom: 0 ;
  margin-left: 1.5em }

div.sidebar {
  margin: 0 0 0.5em 1em ;
  border: medium outset ;
  padding: 1em ;
  background-color: #ffffee ;
  width: 40% ;
  float: right ;
  clear: right }

div.sidebar p.rubric {
  font-family: sans-serif ;
  font-size: medium }

div.system-messages {
  margin: 5em }

div.system-messages h1 {
  color: red }

div.system-message {
  border: medium outset ;
  padding: 1em }

div.system-message p.system-message-title {
  color: red ;
  font-weight: bold }

div.topic {
  margin: 2em }

h1.section-subtitle, h2.section-subtitle, h3.section-subtitle,
h4.section-subtitle, h5.section-subtitle, h6.section-subtitle {
  margin-top: 0.4em }

h1.title {
  text-align: center }

h2.subtitle {
  text-align: center }

hr.docutils {
  width: 75% }

img.align-left, .figure.align-left, object.align-left, table.align-left {
  clear: left ;
  float: left ;
  margin-right: 1em }

img.align-right, .figure.align-right, object.align-right, table.align-right {
  clear: right ;
  float: right ;
  margin-left: 1em }

img.align-center, .figure.align-center, object.align-center {
  display: block;
  margin-left: auto;
  margin-right: auto;
}

table.align-center {
  margin-left: auto;
  margin-right: auto;
}

.align-left {
  text-align: left }

.align-center {
  clear: both ;
  text-align: center }

.align-right {
  text-align: right }

/* reset inner alignment in figures */
div.align-right {
  text-align: inherit }

/* div.align-center * { */
/*   text-align: left } */

.align-top    {
  vertical-align: top }

.align-middle {
  vertical-align: middle }

.align-bottom {
  vertical-align: bottom }

ol.simple, ul.simple {
  margin-bottom: 1em }

ol.arabic {
  list-style: decimal }

ol.loweralpha {
  list-style: lower-alpha }

ol.upperalpha {
  list-style: upper-alpha }

ol.lowerroman {
  list-style: lower-roman }

ol.upperroman {
  list-style: upper-roman }

p.attribution {
  text-align: right ;
  margin-left: 50% }

p.caption {
  font-style: italic }

p.credits {
  font-style: italic ;
  font-size: smaller }

p.label {
  white-space: nowrap }

p.rubric {
  font-weight: bold ;
  font-size: larger ;
  color: maroon ;
  text-align: center }

p.sidebar-title {
  font-family: sans-serif ;
  font-weight: bold ;
  font-size: larger }

p.sidebar-subtitle {
  font-family: sans-serif ;
  font-weight: bold }

p.topic-title {
  font-weight: bold }

pre.address {
  margin-bottom: 0 ;
  margin-top: 0 ;
  font: inherit }

pre.literal-block, pre.doctest-block, pre.math, pre.code {
  margin-left: 2em ;
  margin-right: 2em }

pre.code .ln { color: grey; } /* line numbers */
pre.code, code { background-color: #eeeeee }
pre.code .comment, code .comment { color: #5C6576 }
pre.code .keyword, code .keyword { color: #3B0D06; font-weight: bold }
pre.code .literal.string, code .literal.string { color: #0C5404 }
pre.code .name.builtin, code .name.builtin { color: #352B84 }
pre.code .deleted, code .deleted { background-color: #DEB0A1}
pre.code .inserted, code .inserted { background-color: #A3D289}

span.classifier {
  font-family: sans-serif ;
  font-style: oblique }

span.classifier-delimiter {
  font-family: sans-serif ;
  font-weight: bold }

span.interpreted {
  font-family: sans-serif }

span.option {
  white-space: nowrap }

span.pre {
  white-space: pre }

span.problematic {
  color: red }

span.section-subtitle {
  /* font-size relative to parent (h1..h6 element) */
  font-size: 80% }

table.citation {
  border-left: solid 1px gray;
  margin-left: 1px }

table.docinfo {
  margin: 2em 4em }

table.docutils {
  margin-top: 0.5em ;
  margin-bottom: 0.5em }

table.footnote {
  border-left: solid 1px black;
  margin-left: 1px }

table.docutils td, table.docutils th,
table.docinfo td, table.docinfo th {
  padding-left: 0.5em ;
  padding-right: 0.5em ;
  vertical-align: top }

table.docutils th.field-name, table.docinfo th.docinfo-name {
  font-weight: bold ;
  text-align: left ;
  white-space: nowrap ;
  padding-left: 0 }

/* "booktabs" style (no vertical lines) */
table.docutils.booktabs {
  border: 0px;
  border-top: 2px solid;
  border-bottom: 2px solid;
  border-collapse: collapse;
}
table.docutils.booktabs * {
  border: 0px;
}
table.docutils.booktabs th {
  border-bottom: thin solid;
  text-align: left;
}

h1 tt.docutils, h2 tt.docutils, h3 tt.docutils,
h4 tt.docutils, h5 tt.docutils, h6 tt.docutils {
  font-size: 100% }

ul.auto-toc {
  list-style-type: none }

</style>
</head>
<body>
<div class="document">


<div class="section" id="gitdrive">
<h1>GitDrive</h1>
<p>This is a high level documentation for GitDrive. This will detail the
intended use of the different parts in the project, along with any limitations,
issues, and missing parts/features.</p>
<p>Each section should be stand alone as much as possible. Meaning that no knowledge
of other sections is required to understand the functionality of a section.
That being said knowledge of the program's structure is helpful in understanding
the purpose behind the decisions that were made in designing the app.</p>
</div>
<div class="section" id="the-tech-stack">
<h1>The Tech Stack</h1>
<p>Knowing the tech stack is helpful for understanding the structure. GitDrive is an Electron
app written in TypeScript. The Electron part means the app has two parts. The <em>main process</em>
and the <em>renderer process</em>.</p>
<dl class="docutils">
<dt>The main process:</dt>
<dd>Its what the app launches first, it's where the node run environment is and
it's responsible for launching the renderer process/s. This is usually seen as the backend
part where the logic is kept.</dd>
<dt>The renderer process:</dt>
<dd>Contains the Chrome V8 engine along with access to the node environment APIs. This is what
user interacts with and could consist of more than one window.</dd>
</dl>
<p>These two parts communicate on channels using something called ipcMain and ipcRenderer.
The ipc part stands for intra process communication. Each process is able to set listeners and send
messages on channels on its respective ipc object.</p>
<p>This should be enough for an overall idea, for a more in depth look, the <a class="reference external" href="https://electronjs.org/docs">Electron</a> documentation
does a fantastic job. Also make sure to check <a class="reference external" href="https://github.com/sindresorhus/awesome-electron">awesome-electron</a> for everything Electron related.</p>
<p>TypeScript is a structurally typed super set of javascript. This means that the app is transpiled
into javascript. It also means the code is type checked. This makes our code easier to refractor and
write with an IDE that supports TypeScript. It is recommended to look at the TypeScript <a class="reference external" href="https://www.typescriptlang.org/docs/handbook/basic-types.html">handbook</a>
before diving into reading/writing any code.</p>
<dl class="docutils">
<dt>The rest of the stack without build related dependencies is as follows:</dt>
<dd><ul class="first last simple">
<li><a class="reference external" href="https://github.com/desktop/dugite">Dugite</a>: A Typescript binder to Git's command line.</li>
<li><a class="reference external" href="https://mochajs.org/">Mocha</a>: A test suite for javascript node applications.</li>
<li><a class="reference external" href="http://www.chaijs.com/">Chai</a>: Chai is a BDD / TDD assertion library to be used in mocha tests.</li>
<li><a class="reference external" href="https://developers.google.com/protocol-buffers/">Google-protobuf</a>: A language-neutral, platform-neutral mechanism for serializing structured data.</li>
<li><a class="reference external" href="https://vuejs.org">Vue</a>: A <em>progressive framework</em> for building responsive user interfaces. A bunch of vue related libraries are used as well.</li>
<li><a class="reference external" href="https://github.com/jprichardson/node-fs-extra">Fs-extra</a>: Adds to the native node fs module methods and adds promise support to existing ones.</li>
</ul>
</dd>
</dl>
</div>
<div class="section" id="the-structure">
<h1>The structure</h1>
<p>The application is a Model-View-Controller (MVC). The Model consists of the main Git commands that are
wrapped into the app commands. The app commands are listed in <a class="reference internal" href="#the-app">The App</a>. <a class="reference internal" href="#the-controller">The controller</a> part
consists of some state-hub logic integrated into the Vuex store then components. Then <a class="reference internal" href="#the-view">the view</a>
is specified per Vue component. This makes parts of the view (components) reuseable in whichever
context the user desires.</p>
<p>The file tree structure is explained below:</p>
<ul class="simple">
<li><strong>docs</strong>: Is where this file resides, ie. the documentation.</li>
<li><strong>build</strong>: It is where the app gets transpiled.</li>
<li><dl class="first docutils">
<dt><strong>src</strong>: Where the app resides.</dt>
<dd><ul class="first last">
<li><strong>components</strong>: Where we keep the Vue components.</li>
<li><strong>examples</strong>: A bunch of examples for how the code should be used.</li>
<li><dl class="first docutils">
<dt><strong>git-drive</strong>: The logic for the app models is kept here.</dt>
<dd><ul class="first last">
<li><strong>app</strong>: The logic behind the main app commands: add-topicspace, ..., load-repo, start, ...</li>
<li><strong>controller</strong>: Where the logic for the controller is kept.</li>
<li><strong>git</strong>: The logic behind the core git commands is kept here.</li>
</ul>
</dd>
</dl>
</li>
<li><strong>main</strong>: The entry point for the main process, this is where webpack will look.</li>
<li><dl class="first docutils">
<dt><strong>model</strong>: The model class objects abstraction is kept here.</dt>
<dd><ul class="first last">
<li><strong>app</strong>: The app classes/models.</li>
<li><strong>controller</strong>: The controller classes/models.</li>
<li><strong>git</strong>: The git classes/models.</li>
</ul>
</dd>
</dl>
</li>
<li><strong>renderer</strong>: The entry point for the renderer process/s, webpack will look here.</li>
<li><strong>store</strong>: The Vuex store lies here, all the mutations, actions, and getters logic is here.</li>
<li><dl class="first docutils">
<dt><strong>tests</strong>: The app tests, they are not transpiled like the rest of the dirs in src.</dt>
<dd><ul class="first last">
<li><strong>app</strong>: Tests for the app logic.</li>
<li><strong>controller</strong>: Tests for the controller logic.</li>
<li><strong>git</strong>: Tests for the core git commands.</li>
<li><strong>testRepos</strong>: Toy repos for testing stuff on.</li>
</ul>
</dd>
</dl>
</li>
<li><strong>util</strong>: Utility functions that might be useful for any other parts in the app.</li>
</ul>
</dd>
</dl>
</li>
<li><strong>static</strong>: Files that are used as is.</li>
<li><strong>.electron-vue</strong>: The webpack config and run scripts are here.</li>
<li><strong>template</strong>: Like static but its meant to be used by users not the app itself.</li>
</ul>
<hr class="docutils" />
<p>Notice how the <em>git-drive</em>, <em>model</em> and <em>tests</em> directories share the same structure.</p>
<p>The <a class="reference internal" href="#protobuf">protobuf</a> coupling/abstraction is specified within each model.</p>
</div>
<div class="section" id="the-build-process">
<h1>The Build Process</h1>
<p>Our build process is not that involved but not trivial at the same time. Looking at the <a class="reference external" href="../package.json">package.json</a>
scripts we notice 11 of them, most are not stand alone callable, here is the layout:</p>
<div class="section" id="dev-build">
<h2>Dev-Build</h2>
<p>The start script is the one responsible this and has four steps. The first one is just cleaning the
build directory. The second step transpiles the app from TypeScript to javascript into the build
directory. The third runs the linter, based on the rules in <a class="reference external" href="../tsconfig.json">tsconfig.json</a>. The fourth and last,
actually launches the app using webpack from the build/main and build/renderer directories</p>
</div>
<div class="section" id="production-build">
<h2>Production-Build</h2>
<p>The dist (short for distribute) scripts are responsible for this. So far this is not functional.
I will finalize this and update the section accordingly.</p>
</div>
<div class="section" id="app-packaging">
<h2>App-Packaging</h2>
<p>The pack scripts are responsible for this. So far this is not functional as well. Will update
the section once it is functional.</p>
</div>
<div class="section" id="testing">
<h2>Testing</h2>
<p>The test script is the one responsible for this. The script runs any tests specified in the
src/test directory. The test assume the ts-node npm module to be installed globally as it is
responsible for transpiling the TypeScript tests in runtime thus it is not possible to run the
tests without it.</p>
<hr class="docutils" />
<p>Notice how I did not go through any of the webpack setup or build configs. They are very standard
and self explaining to whoever knows anything about webpack. I know enough to make what is there now
work.</p>
<p>One thing worth mentioning is that none of the components are actually transpiled, they are compiled
in runtime using vue-loader and a bunch of other modules. This means when any of these are referenced,
ie. imported, they are referenced with respect to them existing in src/components directory not build/*
directory like the rest of the code.</p>
</div>
</div>
<div class="section" id="terminology">
<h1>Terminology</h1>
<p>Below are formal definitions of each concept. Use this to help reason about and understand them.</p>
<dl class="docutils">
<dt><strong>GRepository</strong></dt>
<dd>Our own definition of a repository. It will consist of a group of one or more TopicSpaces.
Each repository has a &quot;Main&quot; topicspace among other ones. The repository has a name that
cannot be longer than a 100 character. Also each user in the repository must have a unique
name. Finally, each repository can have none or only one remote repository linked to it. The
name of the remote repository if it exists is &quot;origin&quot;.</dd>
<dt><strong>TopicSpace</strong></dt>
<dd>A group of one or more WorkSpaces. Since each workspace can only have one user, the number
of users has to match the number of workspaces. The name as well has to be less than a 100
characters.</dd>
<dt><strong>WorkSpace</strong></dt>
<dd>A single branch for one user only. Meaning that only the user is allowed to commit on this branch.
This way we can get who the user is by reading the tip's commit author information. The name of
the branch starts with a capital &quot;G&quot; letter then the first 10 characters in the first
commitish. The &quot;G&quot; is added to avoid ambiguity in Git when referencing the branch ref and
actual commit SHAs. This naming schema grants us unique names for quite a long time, a proof way
is to make the length of the SHA characters adapt to the total number of workspaces, maybe one
day in the future.</dd>
<dt><strong>Sync</strong></dt>
<dd>For a user and a workspace, the operation does a commit followed by a push of the workspace then
a fetch of all workspaces. This requires the branch checked-out to match the given workspace. It
will also check that the given user owns the given workspace.</dd>
<dt><strong>Dispatcher</strong></dt>
<dd>Where all the data-flow is handled along with events. It can control one or more app states. Any
reads, writes to data should go through here. This will ensure the consistency of such operations
and will make extending on them easier.</dd>
<dt><strong>App-State</strong></dt>
<dd>A state that is tied to a browser window and app-data. The browser window coupling is not done
yet. As for the app-data, this class is responsible for mutating the app-data state in a
consistent state. This means creating a new object with every mutation since app-data is immutable.
This class is also responsible for exposing any info from app-data. One might ask by now why not
have app-data as a part of the Dispatcher instead of doing this. The reason is for the future where
the app might have multiple windows in which dispatcher (or an api it will call) will be tasked
with keeping information between them consistent.</dd>
<dt><strong>FS Explorer</strong></dt>
<dd>The right bottom panel responsible for exploring the currently selected workspace. It will show
directories/files and offer operations on them accordingly. These operations are tbd but one
will be to show the history progression. This means show the linear line of commits that affected
the directory or file in the selected workspace.</dd>
<dt><strong>Header Menu</strong></dt>
<dd>Its the top panel where the app commands will reside. These commands will chang based on thei
context, ie. the current repo, current topicspace, and current workspace.</dd>
<dt><strong>TS Pane</strong></dt>
<dd>Its the left panel where the user browses the current repo's topicspaces and workspaces.
WorkSpaces are named based on their users.</dd>
<dt><strong>App Data</strong></dt>
<dd>The metadata that will be cached in between app sessions, such as current repos, current user,
repos, etc. This class is coupled with a protobuf message, thus this is how it will be written
and read.</dd>
<dt><strong>Store</strong></dt>
<dd>The Vuex store, where the controller (dispatcher) meets the view. So the Vue component tree
only allowsfor information to flow from parents to children using something they call props.
This proves difficult if sibling components want to communicate information with each other.
This problem can be solved by using a global data store as a single source of truth in which
the entire component tree has access to the data in it using a defined set of interactions.
These interactions are either getting the data, mutating the data, or doing an async action
that might mutate the data eventually. By doing this our state transitions are clear to
follow and thus debug.</dd>
</dl>
</div>
<div class="section" id="the-git-core">
<h1>The Git Core</h1>
<p>This section assumes a certain level of comfort with Git commands, terminology and concepts.</p>
<p>This consists of the core Git commands that we wrap around with the help of dugite. A lof of
these are inspired or sometimes copied from the <a class="reference external" href="https://github.com/desktop/desktop">GitHub Desktop</a> project, thanks to them
for that.</p>
<p>The list below will have commands that are exposed in multiple ways that depend on the
options given to the command. So in reality we have an 19 amount of Git commands/behaviors
exposed. Each command will also have an explanation of the purpose from including it along
with an explanation of why its exposed in such a way.</p>
<p>Also all the commands will not attempt to handle any error they encounter and will throw it
to the caller. The errors thrown follow the structure explained under core-git below.</p>
<p>Here are the commands in alphabetical order:</p>
<blockquote>
<dl class="docutils">
<dt><strong>1.Add:</strong></dt>
<dd>This will stage everything in the working tree. All changes no matter what they are
will get staged. We do not expose partial staging (staging per file) since we have no
use for it in our functionality. Partial staging is still achievable, if needed,
using partial resets. A partial reset with the right option will effectively undo
an add. The addOptions param is experimental, ie. not tested at all.</dd>
<dt><strong>2.Branch:</strong></dt>
<dd><p class="first">We have two actions from the branch command.</p>
<p>The first is to create a branch, which given a valid name with length less than a
100 characters and a committish tip will create a branch at the committish. HEAD has
to be explicitly specified to avoid ambiguity.</p>
<p class="last">The second is renaming a branch, which given a branch and a new valid name
will rename the branch to that name. We use rename while creating workspaces after we
create the first commit on them since we need the first 10 SHAs characters from it.</p>
</dd>
<dt><strong>3.Checkout:</strong></dt>
<dd><p class="first">We have four actions from the checkout command.</p>
<p>The first is just a normal checkout of a ref. Usually the ref will be a branch object,
in fact this command is only used to checkout branches. The reason behind accepting
a string is because of metadata branches. It turned out its a lot of headache to keep
track of the metadata branch in a branch object so we only keep track of its ref name
per repository and we used that name (string) to checkout when needed.</p>
<p>The second is our beloved partial checkout. Given a list of paths and ref, the command
will checkout the state of those paths based on the ref into the current working tree.
This operation should be run on an empty workspace.</p>
<p>The third is orphan checkout. Given a new branch name and a starting point, it will
create an orphan branch based on the point. An orphan branch points to not commits,
effectively breaking the history. This will be used when we create a new topicspace
to ensure their independence.</p>
<p class="last">The fourth is to checkout and create a branch. Given a branch name and a start point
it creates a branch at that point and checks it out. This is just here to save us a
shell-out call, its two birds one stone.</p>
</dd>
<dt><strong>4.Clone:</strong></dt>
<dd><p class="first">We have one action from the clone command.</p>
<p class="last">Its your normal clone call. Given a valid url and a path, it will clone the url
repository into that path. There is a bit of work to be done on that command. We still
need to figure out authentication. We disable the use of any default authentication
handlers in order to implement ours. Will update the section once its done.</p>
</dd>
<dt><strong>5.Commit:</strong></dt>
<dd><p class="first">We have one acton from the commit command.</p>
<p class="last">Its a commit but with stuff baked in it. So given an author's name and email, a summary
and a message, it will create a commit under HEAD with author and email set. Before
committing, it will unstage everything then stage it all again.</p>
</dd>
<dt><strong>6.core-git:</strong></dt>
<dd>This is just a wrapper around the dugite exec command. The wrapper is meant to be used
to extend on the error handling and result of dugite's api. The class GitError defines
our errors in which each error has a human readable description of the error,
the errored command's arguments, the error enum from dugite/errors.ts, and the
actual text of the error. An error is triggered whenever the process returns with a none
zero exit code. The wrapper does not attempt to handle any errors, its all left to the
caller.</dd>
<dt><strong>7.Diff-index:</strong></dt>
<dd><p class="first">We have one action from the command. The code for this was taken from the
<a class="reference external" href="https://github.com/desktop/desktop">GitHub Desktop</a> project.</p>
<p class="last">As the name suggests, the command will return a list of of files who have changes in the
indexing are when compared against HEAD.</p>
</dd>
<dt><strong>8.Diff:</strong></dt>
<dd><p class="first">We have five actions from the diff command. The code for this was take from the
<a class="reference external" href="https://github.com/desktop/desktop">GitHub Desktop</a> project.</p>
<p>The first is for getting a commit's diff. Given a file and a commitish, it will return
the diff of the file between the commit and the commit's parent. This could be used to
check if a commit introduces a change to a file. This command is actually an exception in
the fact that it uses log instead of the diff command, it returns a diff though and that is
what matters.</p>
<p>The second is for getting a diff between a file and the working tree. Given a file, the
command renders the diff for a file within the repository working tree. The file
will be compared against HEAD if it's tracked, if not it'll be compared to an empty
file meaning that all content in the file will be treated as additions.</p>
<p>The third for getting an image diff. This is not going to be used for now, it is there
since I didn't write this code.</p>
<p>The fourth is a utility function that converts rawDiff or changes to an IDiff object. This
is implementation specific, its exported since it might be useful given the type of diff
a user posses. Explaining the command is tedious and not necessary.</p>
<p class="last">The fifth is for getting a binary blob of an image. Again for now this is not used.</p>
</dd>
<dt><strong>9.Fetch:</strong></dt>
<dd><p class="first">There are two actions from the fetch command.</p>
<p>The first is to just fetch all the refs in a repository. Given that our repositories will
only have one remote branch called origin then we fetch all the refs from it. Notice how the
command does not check whether the remote repository exist in the given repository. This
check if left for the caller to do as it might become redundant.</p>
<p>The second is for fetching a specific ref. Given the name of the ref the function will fetch
it down. Again this does fetch from origin and does not check whether the remote repository
exists. This also does not check the existance of the given ref.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notice:</th><td class="field-body">The authentication is not implemented for this as well, in fact it is not
implemented for any network related command.</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>10.For-each-ref:</strong></dt>
<dd><p class="first">There is one action from this command.</p>
<p class="last">Its a getter for refs in the repository based on a namespace. So given a namespace, the
command will return an array with all the refs under the namespace. For example, giving
the command refs/heads will return all the local branches. Another example is giving the
command remotes/origin will return all the remote refs in remote repository origin. Call
the function with just a repository to get all the refs.</p>
</dd>
<dt><strong>11.Init:</strong> 19</dt>
<dd><p class="first">There is one action from this command.</p>
<p class="last">Its just an init of a repo given a path that exists. Notice that the function does not
check if the path exists, this is left for the caller.</p>
</dd>
<dt><strong>12.Log:</strong></dt>
<dd><p class="first">There are three actions from this command. This code was taken from the <a class="reference external" href="https://github.com/desktop/desktop">GitHub Desktop</a>
project.</p>
<p>The first is a getter of commits. Given a revision range (a git defined concept), and a
limit the command will return an array of the commits that fall within the range.</p>
<p>The second gets the changed files per commit. Given a commitish, the command will
return an array the files that were changed by the commit.</p>
<p class="last">The third retrieves a single commit based on a ref. Given a ref, the command will return
the commit the ref is pointing to or null if the ref doesn't point to a commit.</p>
</dd>
<dt><strong>13.Pull:</strong></dt>
<dd><p class="first">There is one action from the pull command.</p>
<p>Its just a normal pull of the current HEAD. This should not be used and is there only for the
possibility of needing it. The main problem is that users can make commits through GitHub,
commits that won't follow our rules and we have to deal with it. We will see. We maybe able to
tolerate the owner of the branch rebasing some remote commits made on their own branch.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notice:</th><td class="field-body">Authentication is not implemented.</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>14.Push:</strong></dt>
<dd><p class="first">Similar to fetch, there are two actions from the push command.</p>
<p>The first is just a push of a branch. Given a branch name, the command will push it to its
tracked upstream branch, origin in our case.</p>
<p>The second is a push of all refs. Again this will push to origin.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notice:</th><td class="field-body"><dl class="first last docutils">
<dt>None of these commands checks if origin is setup, this is left to the caller.</dt>
<dd><p class="first last">Also authentication is not implemented.</p>
</dd>
</dl>
</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>15.Remote:</strong></dt>
<dd><p class="first">There are three actions from the remote command.</p>
<p>The first is a getter of a remote. Given a repository, the command will return the one and
only remote as an IRemote object, the object will contain the name and url.</p>
<p>The second is to add origin. Given a url, the command will add origin with the url into the
remote repositories list.</p>
<p class="last">The third is to change the remote repo. Given new url, the command will change the url of
origin to the url given.</p>
</dd>
<dt><strong>16.Reset:</strong></dt>
<dd><p class="first">There are three actions from the reset command.</p>
<p>The first is a ref based reset. Given a ref and a reset mode, the command will reset the
current working tree to that ref based on the mode given.</p>
<p>The second is a path based reset. Given a ref, a mode and a list of paths, the command will
reset the current working tree's paths to the state in the ref based on the mode.</p>
<p>The third is a HEAD based reset. When called on a repo, the command will effectively
un-stage all the changes in the current working tree.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notice:</th><td class="field-body">Given the ResetMode enum, there are only two reset modes possible to use,
soft and mixed resets. Hard resets are not possible.</td>
</tr>
</tbody>
</table>
</dd>
<dt><strong>17.Rev-parse:</strong></dt>
<dd><p class="first">There are two actions from the rev-parse command.</p>
<p>The first is a getter of the top level path of a repository. Given a path, the function
will return the top level absolute path of that git repository or null if it isn't a
git repository.</p>
<p class="last">The second verifies wether the path is a root of git repository. Given a path, the
function will use the one above to return whether the path is the root path in a
repository or it isn't. This is used to determine whether we can start a repository
at a path or not, because if its already a repository we cannot. The fact that we
only care about the root path is because we want the user to be able to nest their
repositories within each other. Nesting repositories is easy as long as the
.gitignore files are updated correctly.</p>
</dd>
<dt><strong>18.Show:</strong></dt>
<dd><p class="first">There are two closely related actions from the show command.</p>
<p>The first gets the binary blob content of a file based on a commit. Given a commitish,
and a path, the function will return a buffer that contains the contents of the file
based on the commitish. This function is super helpful when reading from the metadata
branch for example. Using it we are able to read the metadata protobuf file without
having to checkout the branch.</p>
<p class="last">The second is just like the first except that it takes a length argument. The length
represents the maximum amount of bytes to be read from the file. This is helpful if
its anticipated the file is going to be too big.</p>
</dd>
<dt><strong>19.Statue:</strong></dt>
<dd><p class="first">There is one action from the statue command. This code was taken from the
<a class="reference external" href="https://github.com/desktop/desktop">GitHub Desktop</a> project.</p>
<p>Its a getters for the current working tree status based from the top level of the
repository. When run on a repository the command will return an IStatusResult object
that contains: The name of the current branch, the current upstream branch
(if it exists), the current tip commit's SHA, whether the branch is ahead or
behind its upstream, if the repository exists, and lastly a WorkingDirectoryStatus
object that has a list of WorkingDirectroyFileChanges of the current files to be
staged in the current working tree.</p>
<table class="last docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field"><th class="field-name">Notice:</th><td class="field-body"><p class="first">There is no explicit notion of partial staging, the way to do it is to give
the WorkingDirectoryStatus class (in model/status.ts) a selected list of
WorkingDirectroyFileChanges.</p>
<p class="last">Also the command will not have any relative paths for the files it returns
since it is run from the top level of the repository. The status command's
output changes based on the current working directory.</p>
</td>
</tr>
</tbody>
</table>
</dd>
</dl>
</blockquote>
</div>
<div class="section" id="protobuf">
<h1>Protobuf</h1>
</div>
<div class="section" id="the-app">
<h1>The App</h1>
</div>
<div class="section" id="the-controller">
<h1>The Controller</h1>
</div>
<div class="section" id="the-view">
<h1>The View</h1>
</div>
</div>
</body>
</html>
